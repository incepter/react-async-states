"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[798],{6131:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return u},default:function(){return m}});var a=n(7896),r=n(1461),i=(n(2784),n(876)),l=["components"],o={sidebar_position:3,sidebar_label:"useAsyncState"},s="useAsyncState",d={unversionedId:"api/use-async-state",id:"api/use-async-state",isDocsHomePage:!1,title:"useAsyncState",description:"This hook allows subscription to an async state, and represents the API that you will be interacting with the most.",source:"@site/docs/api/use-async-state.md",sourceDirName:"api",slug:"/api/use-async-state",permalink:"/react-async-states/docs/api/use-async-state",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,sidebar_label:"useAsyncState"},sidebar:"tutorialSidebar",previous:{title:"AsyncStateProvider",permalink:"/react-async-states/docs/api/provider"},next:{title:"useAsyncStateSelector",permalink:"/react-async-states/docs/api/use-async-state-selector"}},u=[{value:"Standalone vs Provider",id:"standalone-vs-provider",children:[],level:3},{value:"Subscription modes",id:"subscription-modes",children:[],level:3},{value:"Configuration and manipulation",id:"configuration-and-manipulation",children:[],level:3},{value:"Examples",id:"examples",children:[],level:3},{value:"Other hooks",id:"other-hooks",children:[],level:3}],p={toc:u};function m(t){var e=t.components,n=(0,r.Z)(t,l);return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"useasyncstate"},(0,i.kt)("inlineCode",{parentName:"h1"},"useAsyncState")),(0,i.kt)("p",null,"This hook allows subscription to an async state, and represents the API that you will be interacting with the most.\nIts signature is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function useAsyncState(configuration, dependencies) {}\n")),(0,i.kt)("p",null,"It returns an object that contains few properties, we'll explore them in a moment."),(0,i.kt)("h3",{id:"standalone-vs-provider"},"Standalone vs Provider"),(0,i.kt)("p",null,"This hooks may be used inside and outside the provider and has almost the same behavior."),(0,i.kt)("p",null,"For example, you can use this hook to fetch the current user from your api before mounting the provider and pass the user\ninformation to payload."),(0,i.kt)("p",null,"While being outside provider, it will expect you to use a producer function as configuration, or with an object defining\nthe producer and all other necessary information."),(0,i.kt)("h3",{id:"subscription-modes"},"Subscription modes"),(0,i.kt)("p",null,"Many subscription modes are possible. You won't have to use them, but you should essentially\nknow what they mean and how your configuration impacts them for any debugging purposes."),(0,i.kt)("p",null,"What is a subscription mode already ?\nWhen you call ",(0,i.kt)("inlineCode",{parentName:"p"},"useAsyncState")," -every time your component renders- this hook reacts to the given configuration\nsynchronized by your dependencies. Then, tries to get the async state instance from the provider."),(0,i.kt)("p",null,"If not found, it may wait for it if you did not provide a ",(0,i.kt)("inlineCode",{parentName:"p"},"producer")," function in your configuration, or fallback with a noop mode for example."),(0,i.kt)("p",null,"The possible subscription mode are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LISTEN"),": Listens to an existing async state from its key"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"HOIST"),": Registers the async state in the provider, and subscribes to it (more like an injection)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"STANDALONE"),": Mimics the standalone mode"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FORK"),": Fork an existing async state in the provider"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"WAITING"),": When the desired async state does not exist in provider, and you do not want to hoist it"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"SOURCE"),": When you use a source object for subscription"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"SOURCE_FORK"),": When you use a source object for subscription and you decide to fork it"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"OUTSIDE_PROVIDER"),": When you call it outside the async state context provider"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"NOOP"),": If none of the above matches, should not happen")),(0,i.kt)("p",null,"If you are curious about how the subscription mode is inferred, please refer to the ",(0,i.kt)("inlineCode",{parentName:"p"},"inferSubscriptionMode")," function."),(0,i.kt)("h3",{id:"configuration-and-manipulation"},"Configuration and manipulation"),(0,i.kt)("p",null,"The configuration argument may be a string, an object with supported properties, or a producer function (you won't be able to share it by this signature).\nIf it is a string, it is used inside provider to only listen on an async state, without automatically triggering the run\n(but you can do it programmatically using what this hooks returns).\nIf an object is provided, it may act like a simple subscription or a registration of a new async state (with fork/hoist)."),(0,i.kt)("p",null,"Let's see in details the supported configuration:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Property"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Default Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Standalone"),(0,i.kt)("th",{parentName:"tr",align:null},"Provider"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"key")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"string")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"string")),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"The unique key, either for definition or subscription")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"lazy")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"boolean")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"true")),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"If false, the subscription will re-run every dependency change")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"fork")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"boolean")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"false")),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"If true, subscription will fork own async state")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"source")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"object")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"undefined")),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"Subscribes to the hidden instance of async state in this special object")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"producer")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"function")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"undefined")),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"Our producer function")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"selector")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"function")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"identity")),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"receives state (",(0,i.kt)("inlineCode",{parentName:"td"},"{data, args, status}"),") as unique parameter and whatever it returns it is put in the state return")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"areEqual")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"function")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"shallowEqual")),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"(prevValue, nextValue) => areEqual(prevValue, nextValue)")," if it returns true, the render is skipped")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"condition")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"boolean")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"true")),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"If this condition is falsy, run will not be granted")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"forkConfig")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ForkConfig")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"{keepState: false}")),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"defines whether to keep state when forking or not")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"initialValue")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"any")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"null")),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"The initial producer value, useful only if working as standalone(ie defining own producer)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"rerenderStats")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"object")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"{<status>: true}")),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"Defines whether to register in the provider or not")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"hoistToProvider")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"boolean")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"false")),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"Defines whether to register in the provider or not")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"hoistToProviderConfig")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"HoistConfig")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"{override: false}")),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"x"),(0,i.kt)("td",{parentName:"tr",align:null},"Defines whether to override an existing async state in provider while hoisting")))),(0,i.kt)("p",null,"The returned object from useAsyncState contains the following properties:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Property"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"key")),(0,i.kt)("td",{parentName:"tr",align:null},"The key of the async state instance, if forked, it is different from the given one")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"run")),(0,i.kt)("td",{parentName:"tr",align:null},"Imperatively trigger the run, arguments to this function are received as array in the execution args")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"mode")),(0,i.kt)("td",{parentName:"tr",align:null},"The subscription mode")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"state")),(0,i.kt)("td",{parentName:"tr",align:null},"The current selected portion of state, by default, the selector is ",(0,i.kt)("inlineCode",{parentName:"td"},"identity")," and so the state is of shape ",(0,i.kt)("inlineCode",{parentName:"td"},"{status, args, data}"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"abort")),(0,i.kt)("td",{parentName:"tr",align:null},"Imperatively abort the current run if running")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"source")),(0,i.kt)("td",{parentName:"tr",align:null},"The special source object of the subscribed async state instance, could be reused for further subscription without passing by provider or key")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"payload")),(0,i.kt)("td",{parentName:"tr",align:null},"The async state instance payload (could be removed in the future)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"lastSuccess")),(0,i.kt)("td",{parentName:"tr",align:null},"The last registered success")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"replaceState")),(0,i.kt)("td",{parentName:"tr",align:null},"Imperatively and instantly replace state as success with the given value (accepts a callback receiving the old state)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"mergePayload")),(0,i.kt)("td",{parentName:"tr",align:null},"Imperatively merge the payload of the subscribed async state instance with the object in first parameter")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"runAsyncState")),(0,i.kt)("td",{parentName:"tr",align:null},"If inside provider, ",(0,i.kt)("inlineCode",{parentName:"td"},"runAsyncState(key, ...args)")," runs the given async state by key with the later execution args")))),(0,i.kt)("p",null,"We bet in this shape because it provides the key for further subscriptions, the current state with status, data and the\narguments that produced it. ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," runs the subscribed async state, to abort it invoke ",(0,i.kt)("inlineCode",{parentName:"p"},"abort"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"lastSuccess"),"\nholds for you the last succeeded value."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"replaceState")," instantly gives a new value to the state with success status.\n",(0,i.kt)("inlineCode",{parentName:"p"},"runAsyncState")," works only in provider, and was added as convenience to trigger some side effect after\nthe current async producer did something, for example, reload users list after updating a user successfully."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"selector")," as config in for ",(0,i.kt)("inlineCode",{parentName:"p"},"useAsyncState")," allows you to subscribe to just a small portion of the state while\nchoosing when to trigger a rerender, this is an important feature and the probably the most important of this library.\nIt was not designed from the start, but the benefits from having it are noticeable and allowed new extensions for\nthe library itself."),(0,i.kt)("p",null,"Note :"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Calling the ",(0,i.kt)("inlineCode",{parentName:"li"},"run")," function, if it is still ",(0,i.kt)("inlineCode",{parentName:"li"},"pending")," the previous run, it aborts it instantly, and start a new cycle.")),(0,i.kt)("h3",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Let's now make some examples using ",(0,i.kt)("inlineCode",{parentName:"p"},"useAsyncState"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'import {useAsyncState} from "react-async-states";\n\n// later and during render\n\n// executes currentUserPromise on mount\nconst {state: {data, status}} = useAsyncState({key: "current-user", producer: currentUserPromise, lazy: false});\n\n// subscribes to transactions list state\nconst {state: {data: transactions, status}} = useAsyncState("transactions");\n\n// injects the users list state\nconst {state: {data, status}} = useAsyncState({key: "users-list", producer: usersListPromise, lazy: false, payload: {storeId}, hoistToProvider: true});\n\n// forks the list of transactions for another store (for preview for example)\n// this will create another async state issued from users-list -with a new key (forked)- without impacting its state\nconst {state: {data, status}} = useAsyncState({key: "users-list", payload: {anotherStoreId}, fork: true});\n\n// reloads the user profile each time the match params change\n// this assumes you have a variable in your path\n// for example, once the user chooses a profile, just redirect to the new url => matchParams will change => refetch as non lazy\nconst matchParams = useParams();\nconst {state} = useAsuncState({\n  ...userProfilePromiseConfig, // (key, producer), or take only the key if hoisted and no problem impacting the state\n  lazy: false,\n  payload: {matchParams}\n}, [matchParams]);\n\n// add element to existing state via replaceState\nconst {state: {data: myTodos}, replaceState} = useAsyncState("todos");\nfunction addToDo(data) {\n  replaceState(old => ({...old, [data.id]: data}));\n}\n\n// add element to existing state via run (may be a reducer)\n// run in this case acts like a `dispatch`\nconst {state: {data: myTodos}, run} = useAsyncState("todos");\n\nfunction addTodo(data) {\n  run({type: ADD_TODO, payload: data});\n}\nfunction removeTodo(id) {\n  run({type: REMOVE_TODO, payload: id});\n}\n\n// a standalone async state (even inside provider, not hoisted nor forked => standalone)\nuseAsyncState({\n  key: "not_in_provider",\n  payload: {\n    delay: 2000,\n    onSuccess() {\n      showNotification();\n    }\n  },\n  producer(argv) {\n    timeout(argv.payload.delay)\n    .then(function callSuccess() {\n      if (!argv.aborted) {\n        // notice that we are taking onSuccess from payload, not from component\'s closure\n        // that\'s the way to go, this creates a separation of concerns\n        // and your producer may be extracted outisde this file, and will be easier to test\n        // but in general, please avoid code like this, and make it like an effect reacting to a value\n        // (the state data for example)\n        argv.payload.onSuccess();\n      }\n    })\n  }\n});\n\n// hoists a controlled form to provider\nuseAsyncState({\n  key: "some-form",\n  producer(argv) {\n    const [name, value] = argv.args;\n    if (!name) {\n      return argv.lastSuccess.data;\n    }\n    return {...argv.lastSuccess.data, [name]: value};\n  },\n  hoistToProvider: true,\n  rerenderStatus: {pending: false, success: false},\n  initialValue: {}\n});\n// later\n<Input name="username" />\n<Input name="password" />\n<Input name="phoneNumber" />\n// where\nfunction Input({name, ...rest}) {\n  const {state, run} = useAsyncState({\n    key: "login-form",\n    selector: state => state.data[name],\n  }, [name]);\n  return //...\n}\n\n')),(0,i.kt)("h3",{id:"other-hooks"},"Other hooks"),(0,i.kt)("p",null,"For convenience, we've added many other hooks with ",(0,i.kt)("inlineCode",{parentName:"p"},"useAsyncState")," to help inline most of the situations: They inject\na configuration property which may facilitate using the library:"),(0,i.kt)("p",null,"The following are all hooks with the same signature as ",(0,i.kt)("inlineCode",{parentName:"p"},"useAsyncState"),", but each predefines something in the configuration:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"useAsyncState.auto"),": adds ",(0,i.kt)("inlineCode",{parentName:"li"},"lazy: false")," to configuration"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"useAsyncState.lazy"),": adds ",(0,i.kt)("inlineCode",{parentName:"li"},"lazy: true")," to configuration"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"useAsyncState.fork"),": adds ",(0,i.kt)("inlineCode",{parentName:"li"},"fork: true")," to configuration"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"useAsyncState.hoist"),": adds ",(0,i.kt)("inlineCode",{parentName:"li"},"hoistToProvider: true")," to configuration"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"useAsyncState.hoistAuto"),": adds ",(0,i.kt)("inlineCode",{parentName:"li"},"lazy: false, hoistToProvider: true")," to configuration"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"useAsyncState.forkAudo"),": adds ",(0,i.kt)("inlineCode",{parentName:"li"},"lazy: false, fork: true")," to configuration")),(0,i.kt)("p",null,"These are functions produce hooks with the same signature as ",(0,i.kt)("inlineCode",{parentName:"p"},"useAsyncState")," (and hooks shortcuts with it)\nwhile injecting specific properties. They do not work like the other shortcuts because they need an input for\nthe property from the developer:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"useAsyncState.payload"),": adds ",(0,i.kt)("inlineCode",{parentName:"li"},"payload")," to configuration"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"useAsyncState.selector"),": adds a selector"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"useAsyncState.condition"),": make the run conditional")),(0,i.kt)("p",null,"The following snippets results from the previous hooks:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// automatically fetches the user's list when the search url changes\nconst {state: {status, data}, run, abort} = useAsyncState.auto(DOMAIN_USER_PRODUCERS.list.key, [search]);\n// automatically fetches user 1 and selects data\nconst {state} = useAsyncState.selector(s => s.data).auto(user1Source);\n// automatically fetches user 2 and selects its name\nconst {state} = useAsyncState.selector(name).auto(user2Source);\n// automatically fetches user 3 and hoists it to provider and selects its name\nconst {state} = useAsyncState.payload({userId: 3}).selector(name).hoistAuto(userPayloadSource);\n// forks userPayloadSource and runs it automatically with a new payload and selects the name from result\nconst {state} = useAsyncState.selector(name).payload({userId: 4}).forkAuto(userPayloadSource);\n")))}m.isMDXComponent=!0}}]);