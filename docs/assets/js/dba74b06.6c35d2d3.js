"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[298],{4993:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(2983);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=u(n),h=a,m=d["".concat(l,".").concat(h)]||d[h]||p[h]||o;return n?r.createElement(m,s(s({ref:t},c),{},{components:n})):r.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:a,s[1]=i;for(var u=2;u<o;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5797:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>u});var r=n(2206),a=(n(2983),n(4993));const o={sidebar_position:1,sidebar_label:"SSR"},s="The server",i={unversionedId:"server/ssr",id:"server/ssr",title:"The server",description:"Usage in the server",source:"@site/docs/server/1-ssr.md",sourceDirName:"server",slug:"/server/ssr",permalink:"/react-async-states/docs/server/ssr",draft:!1,editUrl:"https://github.com/incepter/react-async-states/edit/main/packages/docs/docs/server/1-ssr.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"SSR"},sidebar:"tutorialSidebar",previous:{title:"useData",permalink:"/react-async-states/docs/hooks/use-data"}},l={},u=[{value:"Usage in the server",id:"usage-in-the-server",level:2},{value:"Global sources",id:"global-sources",level:2},{value:"A mandatory <code>Provider</code>",id:"a-mandatory-provider",level:2},{value:"<code>&lt;Hydrate /&gt;</code>",id:"hydrate-",level:3},{value:"<code>&lt;Hydration /&gt;</code>",id:"hydration-",level:3},{value:"<code>NextJs</code>",id:"nextjs",level:3},{value:"Global sources as server side cache",id:"global-sources-as-server-side-cache",level:3}],c={toc:u},d="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"the-server"},"The server"),(0,a.kt)("h2",{id:"usage-in-the-server"},"Usage in the server"),(0,a.kt)("p",null,"When using the library in the server, the same API remains and almost everything\nworks the same, except for few things that we will see right after."),(0,a.kt)("p",null,"It is important to note that the library aims to be consistent in usage\nso you can use it without fear or extra work from your part."),(0,a.kt)("h2",{id:"global-sources"},"Global sources"),(0,a.kt)("p",null,"In the server, there is a single render pass and there are no effects,\nso basically you render an initial HTML that's passed to the client, then\nyou take it from there."),(0,a.kt)("p",null,"Probably the most powerful feature the library offers is the ability to create\npieces of state everywhere globally in your app and then connect to them from\nany component and even manipulate them."),(0,a.kt)("p",null,"This power remains in the server and won't harm you. That's the biggest\nchallenge all state managers face to be able to share state globally and not\nleak it between different users requests."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"react-async-states")," uses a different approach to tackle this problem. Let dive\ndeeper now."),(0,a.kt)("h2",{id:"a-mandatory-provider"},"A mandatory ",(0,a.kt)("inlineCode",{parentName:"h2"},"Provider")),(0,a.kt)("p",null,"In the server, you should provide a ",(0,a.kt)("inlineCode",{parentName:"p"},"Provider")," at the top level of you tree\n(not the top one, but keep it as high as possible). Or else, the library will\nthrow and force you to use it. This is your warranty that nothing will leak\nbetween users and you will still be able to use global states freely."),(0,a.kt)("p",null,"Under the hood, the library just clones your source with all its definition\nand uses a new one without affecting the global one."),(0,a.kt)("p",null,"In the client, it is the global source that's hydrated and that gets the state.\nSo the code looks the same, and works as expected without being leaked."),(0,a.kt)("p",null,"Take a look at this simple counter example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="Providers.tsx"',title:'"Providers.tsx"'},'import { Provider as AsyncStatesProvider } from "react-async-states";\n\nfunction AppProviders({ children }) {\n  return (\n    <Routing>\n      <ThemeContext>\n        // highlight-next-line\n        <AsyncStatesProvider>{children}</AsyncStatesProvider>\n      </ThemeContext>\n    </Routing>\n  );\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="Counter.tsx"',title:'"Counter.tsx"'},'import { createSource, useAsync } from "react-async-states";\n\nconst counter = createSource("counter", null, { initialValue: 2 });\n\nfunction Counter() {\n  const { data: count } = useAsync(counter);\n\n  return (\n    <div>\n      <span>Count is : {count}</span>\n    </div>\n  );\n}\n')),(0,a.kt)("p",null,"This code will work, until you need something that depends from the user request\nor the user itself and the hydration will fail."),(0,a.kt)("p",null,"To address this, the library makes two APIs at your disposal for a general\npurpose solution, and one that's optimized for nextjs usage."),(0,a.kt)("h3",{id:"hydrate-"},(0,a.kt)("inlineCode",{parentName:"h3"},"<Hydrate />")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"useAsync")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"useData")," return a component that allows hydrating that specific\nstate:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'const serverTime = createSource("server-time", null, {\n  initialValue: Date.now(),\n});\n\nfunction ServerTime() {\n  const { data: time, Hydrate } = useData(serverTime);\n\n  return (\n    <div>\n      // highlight-next-line\n      <Hydrate />\n      <span>Server time is : {time}</span>\n    </div>\n  );\n}\n')),(0,a.kt)("p",null,"It will take care of everything for you."),(0,a.kt)("h3",{id:"hydration-"},(0,a.kt)("inlineCode",{parentName:"h3"},"<Hydration />")),(0,a.kt)("p",null,"the ",(0,a.kt)("inlineCode",{parentName:"p"},"Hydration")," component allows you to pass a collections of ",(0,a.kt)("inlineCode",{parentName:"p"},"sources")," that it\nwill hydrate for you:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'import { Hydration, useData } from "react-async-states";\n\nconst serverTime = createSource("server-time", null, {\n  initialValue: Date.now(),\n});\n\nfunction ServerTime() {\n  const { data: time } = useData(serverTime);\n\n  return (\n    <div>\n      // highlight-next-line\n      <Hydration target={[serverTime]} />\n      <span>Server time is : {time}</span>\n    </div>\n  );\n}\n')),(0,a.kt)("h3",{id:"nextjs"},(0,a.kt)("inlineCode",{parentName:"h3"},"NextJs")),(0,a.kt)("p",null,"When using NextJs, you will be able to totally exclude the ",(0,a.kt)("inlineCode",{parentName:"p"},"Hydrate")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"Hydration")," components and leverage the ",(0,a.kt)("inlineCode",{parentName:"p"},"useServerInsertedHTML")," Next API that\nallows you to pass some HTML from the server to the client whenever a suspense\nboundary completes."),(0,a.kt)("p",null,"The library allows a fast path to take advantage of this API in the simplest\npossible way without needing to worry about hydration:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="Providers.tsx"',title:'"Providers.tsx"'},'import { useServerInsertedHTML } from "next/navigation";\nimport { Provider as AsyncStatesProvider } from "react-async-states";\n\nfunction AppProviders({ children }) {\n  return (\n    <Routing>\n      <ThemeContext>\n        // highlight-next-line\n        <AsyncStatesProvider serverInsertedHtmlHook={useServerInsertedHTML}>\n          {children}\n        </AsyncStatesProvider>\n      </ThemeContext>\n    </Routing>\n  );\n}\n')),(0,a.kt)("p",null,"And that's it! that's all you need to unlock everything when using NextJs or any\nframework that offers a similar API."),(0,a.kt)("h3",{id:"global-sources-as-server-side-cache"},"Global sources as server side cache"),(0,a.kt)("p",null,"You may have wondered and had the though of the ability to use the state of the\nserver when cloning sources for a request (state is not cloned by default)."),(0,a.kt)("p",null,"To do so, all you need is: ",(0,a.kt)("inlineCode",{parentName:"p"},"useServerState: true")," passed to ",(0,a.kt)("inlineCode",{parentName:"p"},"useAsync")," or\n",(0,a.kt)("inlineCode",{parentName:"p"},"useData"),". And this way the library can play the role of a server side cache\nthat's co-located with your app with zero latency."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'const countries = createSource("countries", getCountries, {cacheConfig: {...}});\n\nif (isServer) {\n  countries.run();\n}\n\nfunction SomeComponent() {\n  let { data: countriesList } = useData({\n    source: countries,\n    useServerState: true,\n  });\n\n  return <span>We have {countriesList.length} countries.</span>;\n}\n')))}p.isMDXComponent=!0}}]);